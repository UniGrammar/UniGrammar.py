import re
import sre_compile as scc
import sre_constants as sc
import sre_parse as sp
import sys
import typing
import unicodedata
from pprint import pprint

from RichConsole import groups, rsjoin

from .knowledge import CAPTURE_GROUP, LITERAL_STR

_pyVer = tuple(sys.version_info)[:2]


class RXASTNode:
	"""Current AST generated by sre_parse is badly structured and doesn't suit well for our purposes. So we lift into an own AST class for RX first, and then do multiple passes"""

	__slots__ = ("name", "type", "argsDic")
	HIGHLIGHT = (groups.Fore.lightmagentaEx, groups.Fore.lightcyanEx, groups.Fore.lightyellowEx)

	def __init__(self, name: typing.Optional[str], typ: int, argsDic: typing.Mapping[str, typing.Any]):
		self.__class__.name.__set__(self, name)
		self.__class__.type.__set__(self, typ)
		self.__class__.argsDic.__set__(self, argsDic)

	def __getattr__(self, k: str):
		try:
			return self.argsDic[k]
		except KeyError as ex:
			raise AttributeError(*ex.args) from ex

	def __setattr__(self, k: str, v):
		if k in self.__class__.__slots__:
			#raise Exception("Fucking shit, it must never be called in the case of slots")
			getattr(self.__class__, k).__set__(self, v)
		else:
			self.argsDic[k] = v

	def __rsrepr__(self):
		return groups.Fore.lightgreenEx(self.__class__.__name__) + "(" + rsjoin(groups.Fore.lightblueEx(", "), (hl(getattr(self, k).__rsrepr__() if hasattr(getattr(self, k), "__rsrepr__") else repr(getattr(self, k))) for k, hl in zip(self.__class__.__slots__, self.__class__.HIGHLIGHT))) + ")"

	def __repr__(self):
		return str(self.__rsrepr__())


class RecursivePass:
	"""A lot of flexibility is built into this class. Don't optimize it away!"""

	__slots__ = ("preLifter",)

	RECURSIVE_ARG = "children"
	DEPENDS = None  # Used for documenting passes dependencies, not enforced for now

	def __init__(self, preLifter):
		self.preLifter = preLifter

	def shouldProcess(self, node):
		return True

	def processNode(self, parsed):
		raise NotImplementedError

	def processNodeIfNeeded(self, node):
		if self.shouldProcess(node):
			node = self.processNode(node)
		return node

	def shouldRecurse(self, node):
		return hasattr(node, self.__class__.RECURSIVE_ARG)

	def recurseIntoNodeIfNeeded(self, node):
		if self.shouldRecurse(node):
			node = self.recurseIntoNode(node)
		return node

	def processChild(self, node):
		node = self.processNodeIfNeeded(node)
		node = self.recurseIntoNodeIfNeeded(node)
		return node

	def processChildren(self, children):
		return [self.processChild(el) for el in children]

	def recurseIntoNode(self, node):
		children = getattr(node, self.__class__.RECURSIVE_ARG)
		children = self.processChildren(children)
		setattr(node, self.__class__.RECURSIVE_ARG, children)
		return node

	def __call__(self, node):
		return self.processChild(node)


class SingleElPreLifter:
	__slots__ = ("visitor",)

	def __init__(self, visitor):
		self.visitor = visitor

	def __call__(self, node):
		#print(node)
		tp = node[0]
		args = node[1]

		if not isinstance(args, (list, tuple)):
			args = (args,)

		argNames = getattr(self.visitor, tp.name)
		if isinstance(argNames, str):
			argMapping = {argNames: args}
		else:
			argMapping = dict(zip(argNames, args))

		return RXASTNode(None, tp, argMapping)


class REFirstPassVisitor:
	ASSERT = ASSERT_NOT = ("relativePosition", "children")
	if _pyVer >= (3, 9):
		SUBPATTERN = ("id", "unkn1", "unkn2", "children")
	else:
		SUBPATTERN = ("id", "children")

	BRANCH = ("unkn", "children")

	MAX_REPEAT = MIN_REPEAT = ("minCount", "maxCount", "children")

	GROUPREF = ("backRef",)
	GROUPREF_EXISTS = ("backRef", "trueBranch", "falseBranch")

	IN = "args"
	LITERAL = ("charCode",)
	ANY = ("reserved",)

	AT = ("where",)


singleElPreLifter = SingleElPreLifter(REFirstPassVisitor)


class RE_IN_FirstPassVisitor:
	NEGATE = ()
	LITERAL = ("charCode",)
	CATEGORY = ("enumV",)
	RANGE = ("start", "stop")


re_IN_FlatPreLifter = SingleElPreLifter(RE_IN_FirstPassVisitor)


class RecursivePreLifter(RecursivePass):
	"""Creates the initial AST. It is a prerequisite of every other pass because `RecursivePass` assummes that this was done in order to operate. It was possible to implement `RecursivePreLifter` above `RecursivePass` only because recursing is done only after `processNode` is called"""

	__slots__ = ()

	DEPENDS = ()

	def processNode(self, node):
		print(node)
		node.children = [singleElPreLifter(el) for el in node.children]
		return node

	def shouldProcess(self, node):
		return self.shouldRecurse(node)


RecursivePass.DEPENDS = (RecursivePreLifter,)  # The default value.


class Lift_IN_args(RecursivePass):
	"""Lifts `IN` subtrees. They are not lifted in `RecursivePreLifter` because they have own enum namespace, potentially conflicting with `OPCODES`."""

	__slots__ = ()

	DEPENDS = (RecursivePreLifter,)

	def processNode(self, node):
		node.children = [re_IN_FlatPreLifter(el) for el in node.args]
		del node.argsDic["args"]
		return node

	def shouldProcess(self, node):
		return node.type == sc.IN


class CombineLiterals(RecursivePass):
	"""The regex engine used in python treats a sequence of fixed chars as ... sequence of fixed chars.
	For our purposes it may make sense to combine them into words, because some grammars DSLs support keywords, it also allows more compact grammars"""

	__slots__ = ()

	DEPENDS = (RecursivePreLifter, Lift_IN_args)  # without Lift_IN_args children in IN will be incorrect

	def processNode(self, node):
		processed = []
		currentString = []

		def finishStr():
			nonlocal currentString

			if currentString:
				v = "".join(chr(el.charCode) for el in currentString)
				if len(v) == 1:
					typ = sc.LITERAL
				else:
					typ = LITERAL_STR

				res = RXASTNode(None, typ, {"literal": v})
				currentString = []
				processed.append(res)

		for el in node.children:
			if el.type == sc.LITERAL:
				currentString.append(el)
			else:
				finishStr()
				processed.append(el)
		finishStr()

		node.children = processed
		return node

	def shouldProcess(self, node):
		return hasattr(node, "children")


class AttrReplacerPass(RecursivePass):
	"""Replaces one attr with another one"""

	__slots__ = ("shouldDelete",)

	DEPENDS = (RecursivePreLifter,)

	SRC_ID_ATTR = None
	TGT_ID_ATTR = None

	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self.shouldDelete = self.__class__.SRC_ID_ATTR != self.__class__.TGT_ID_ATTR

	def remapValue(self, prevValue):
		raise NotImplementedError

	def processNode(self, node):
		iD = getattr(node, self.__class__.SRC_ID_ATTR)
		iD = self.remapValue(iD)
		if self.shouldDelete:
			del node.argsDic[self.__class__.SRC_ID_ATTR]
		setattr(node, self.__class__.TGT_ID_ATTR, iD)
		return node

	def shouldProcess(self, node):
		raise NotImplementedError


class DecodeIdsBackToNames(AttrReplacerPass):
	"""id to name replacer"""

	__slots__ = ()

	DEPENDS = (RecursivePreLifter,)

	SRC_ID_ATTR = "backRef"
	TGT_ID_ATTR = "backRef"

	def remapValue(self, iD):
		if isinstance(iD, int):
			iD = self.preLifter.groupsInvertedIdx.get(iD, iD)
			if isinstance(iD, int):
				iD = "cap_" + str(iD)
		elif isinstance(iD, str):
			pass
		return iD


class AssignBackRefsNames(DecodeIdsBackToNames):
	"""This pass
	* assigns `name`s to backrefs in the case of named groups"""

	__slots__ = ("shouldDelete",)

	DEPENDS = (RecursivePreLifter,)

	SRC_ID_ATTR = "backRef"
	TGT_ID_ATTR = "backRef"

	NODE_TYPES = frozenset({sc.GROUPREF, sc.GROUPREF_EXISTS})

	def shouldProcess(self, node):
		return node.type in self.__class__.NODE_TYPES


class AssignGroupsNamesAndCaptures(DecodeIdsBackToNames):
	"""This pass
	* assigns `name`s (used as ids in UG) to named capturing groups
	* generates and assigns `name`s (used as ids in UG) to unnamed but indexec capturing groups
	* separates capturing functionality from group functionality. So capturing groups are now 2 nodes, 1 for a group itself, another one for capturing, and uncaptured groups are only 1 node, for the group itself only."""

	__slots__ = ()

	DEPENDS = (RecursivePreLifter,)

	SRC_ID_ATTR = "id"
	TGT_ID_ATTR = "name"

	def processNode(self, node):
		res = None
		node = super().processNode(node)
		iD = node.name  # it is set to anything only if `id` is not None, ...
		if iD is not None:  # ... , so it is a capturing group
			res = RXASTNode(iD, CAPTURE_GROUP, {"children": [node]})
		else:
			res = node
		return res

	def shouldProcess(self, node):
		return node.type == sc.SUBPATTERN and self.__class__.SRC_ID_ATTR in node.argsDic


class EliminateUnneededSingleItemGroups(RecursivePass):
	"""The regexp engine tends to create groups even if there is a single item in it and it is non-capturing.
	We replace the group node with its content in this case"""

	__slots__ = ()

	DEPENDS = (RecursivePreLifter, AssignGroupsNamesAndCaptures)  # must be executed after AssignGroupsNamesAndCaptures, otherwise the info about captures and assigned ids may be lost

	def processNode(self, node):
		if len(node.children) == 1:
			child = node.children[0]
			if child.name is None:
				child.name = node.name
			return child

		return node

	def shouldProcess(self, node):
		return node.type == sc.SUBPATTERN


class AssignLiteralsNames(RecursivePass):
	__slots__ = ()

	DEPENDS = (RecursivePreLifter, CombineLiterals)  # though it doesn't require CombineLiterals be executed to run without an error, the results will be incorrect otherwise

	def processNode(self, node):
		node.name = "CHAR_" + unicodedata.name(node.literal).replace(" ", "_").upper()
		return node

	def shouldProcess(self, node):
		return node.type == sc.LITERAL and node.name is None


class AssignKeywordsNames(RecursivePass):
	__slots__ = ()

	DEPENDS = (RecursivePreLifter, CombineLiterals)

	def processNode(self, node):
		node.name = "KW_" + node.literal
		return node

	def shouldProcess(self, node):
		return node.type == LITERAL_STR and node.name is None


class PythonRXAST:
	__slots__ = ("state", "root", "groupsInvertedIdx")
	PASSES = [
		RecursivePreLifter,
		Lift_IN_args,
		AssignGroupsNamesAndCaptures,
		EliminateUnneededSingleItemGroups,
		AssignBackRefsNames,
		CombineLiterals,
		AssignLiteralsNames,
		AssignKeywordsNames,
	]

	@property
	def pattern(self):
		return self.state

	@classmethod
	def _grammarToChildren(cls, grammar: typing.Union[str, sp.State]) -> typing.Union[sp.State]:
		if isinstance(grammar, str):
			return sp.parse(grammar, sp.SRE_FLAG_VERBOSE)
		if isinstance(grammar, sp.State):
			return grammar

		raise TypeError

	@classmethod
	def _childrenToRoot(cls, children: sp.State) -> RXASTNode:
		return RXASTNode(None, sc.SUBPATTERN, {"id": None, "children": list(children)})

	def _doPasses(self, root: RXASTNode) -> RXASTNode:
		for pasCtor in self.__class__.PASSES:
			pas = pasCtor(self)
			root = pas(root)
			#print("Pass", pas.__class__.__name__, ": ", groups.Fore.lightgreenEx("OK"))
			#pprint(root)
		return root

	def __init__(self, grammarText: typing.Union[str, sp.State]):
		children = self.__class__._grammarToChildren(grammarText)

		try:
			state = children.state  # new pythons
		except:
			state = children.pattern  # old pythons

		self.__class__.state.__set__(self, state)
		self.__class__.groupsInvertedIdx.__set__(self, {v: k for k, v in state.groupdict.items()})

		root = self.__class__._childrenToRoot(children)
		self.__class__.root.__set__(self, root)

		root = self._doPasses(root)
		self.__class__.root.__set__(self, root)
		#print(root)

	def __getattr__(self, k: str):
		return getattr(self.state, k)

	def __setattr__(self, k: str, v):
		setattr(self.state, k, v)

	def __repr__(self):
		#return repr(self.root)
		return repr(self.state)
